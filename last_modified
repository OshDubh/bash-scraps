#!/bin/bash

# Filename: last_modified
# Description: Changes the "last modified" line in a file whenever it is saved
# Author: OshDubh

# function name: get_date_time
# description: Takes a file and returns the full desired date format
get_date_time () {
  local input_file="$1" # get save the file name
  local day=$(date -r $input_file +%d) # get the day number from the timestamp
  local suffix="th" # default suffix

  # change for special cases
  if [[ "$day" != 11 && "$day" != 12 && "$day" != 13 ]]; then
    case ${day: -1} in # get the last digit of the day number
      1) suffix="st";;
      2) suffix="nd";;
      3) suffix="rd";;
    esac
  fi

  echo $(date -r $input_file +"%R on %A, the %d$suffix of %B, %Y.")
}

# funciton name: program
# description: the main loop that constantly runs
program ()
{
    # get the info we need
    file="$1" 
    
    suffix=$(echo $file | sed -e 's|^\(.*\.\)||g')  # get the last modified file's file extension
    script_location=$(dirname "$0")  # get the location of the script

    # exit if there is no template for the file
    [[ -f "$script_location/template_$suffix.txt" ]] || echo "No template exists for the last modified file." || exit

    # intelligently get what line we need to modify from the template
    line=$(cat "$script_location/template_$suffix.txt" | grep "_last_modified_" | sed -e 's|_last_modified_||g' ) # get everything before the match in the line
    [[ -z "$line" ]] && echo "The template for the last modified file does not have a _last_modified_ line." && exit # exit if there is no _last_modified_ line

    # only modify the line if the current line is older than the one derived from the modification time of the file
    current_last_modified_line=$(cat "$file" | grep "$line") # get the current last modified line that exists in the file
    new_last_modified_line="$line$(get_date_time $file)" # what the line should say

    # replace the line if they're not equal
    if [[ "$current_last_modified_line" != "$new_last_modified_line" ]]
    then
      sed -i"._lmbackup.$(date +%s).txt" "s|$current_last_modified_line|$new_last_modified_line|" "$file"
      mv ./*._lmbackup.*.txt $(dirname "$0")
      echo "updated $file to $new_last_modified_line"
    fi
}

# name: get_last_compatable_file
# description: gets the most recently modified file that has a template
get_last_compatable_file ()
{
  local script_location=$(dirname "$0") # get the location of the script
  local suffixes=$(ls "$script_location" | grep "template_" | sed -e 's|template_||g' -e 's|\.txt||g') # get all the suffixes of the templates
  local last_modified=$(ls -t | head -n 1) # get the most recently modified file
  local last_modified_suffix=$(echo $last_modified | sed -e 's|^\(.*\.\)||g') # get the suffix of the most recently modified file

  # go over the files in order of modification and return the first one that has a template
  for file in $(ls -t)
  do
    for suffix in $suffixes
    do
      [[ "$suffix" == "$(echo $file | sed -e 's|^\(.*\.\)||g')" ]] && echo "$file" && return
    done
  done
}

# input_file="$1" # get the file from the cli
# [[ -z "$input_file" ]] && file_flag=1 # if there is no file, set the flag
# [[ "$file_flag" -eq 1 ]] && input_file=$(ls -t | head -n 1) # if there is no file, get the most recently modified file
# echo "watching: $input_file"

# modified=$(date -r $input_file +%s)

# while true;
# do
#   if [[ "$modified" -ne $(date -r $input_file +%s) ]];
#   then
#     program "$input_file"
#   fi
#   modified=$(date -r $input_file +%s)
#   [[ "$file_flag" -eq 1 ]] && input_file=$(ls -t | head -n 1) && echo "watching: $input_file"
#   sleep 1
# done

file=$(get_last_compatable_file)
echo "watching: $file"
modified=$(date -r $file +%s)

while true;
do
  recheck=$(get_last_compatable_file)
  [[ "$file" != "$recheck" ]] && file=$recheck && echo "watching: $file"

  if [[ "$modified" -ne $(date -r $file +%s) ]];
  then
    program $file
  fi

  modified=$(date -r $file +%s)
  sleep 1
done
  